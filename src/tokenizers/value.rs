use crate::TResult;

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Tokenizer<'a, const C: char> {
    pub value: &'a str,
}

impl<'a, const C: char> Tokenizer<'a, C> {
    pub fn tokenize(part: &'a str) -> TResult<'a, Self> {
        use crate::parser_utils::until_newline;
        use nom::{bytes::complete::tag, sequence::preceded};

        let (rem, value) = preceded(tag(Self::prefix().as_str()), until_newline)(part)?;

        Ok((rem, value.into()))
    }

    //TODO: this should be generated by a concat-related macro, but atm at stable this is not
    //possible, will come back once const generics expands on stable
    fn prefix() -> String {
        format!("{}=", C)
    }
}

impl<'a, const C: char> From<&'a str> for Tokenizer<'a, C> {
    fn from(value: &'a str) -> Self {
        Self { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tokenizer() {
        let value = concat!("i=a value here #sdp #rocks\r\nsomething",);

        assert_eq!(
            Ok(("something", "a value here #sdp #rocks".into())),
            Tokenizer::<'i'>::tokenize(value)
        );
    }
}
